%%
% Plantilla de reporte técnico para proyecto de listas enlazadas y sensores IoT
% Basado en plantilla IEEEtran
%
\documentclass[conference]{IEEEtran}

\usepackage[spanish]{babel}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{hyperref}
\usepackage{subfig}
% \usepackage{lipsum} % Comentado ya que no se usa texto de relleno
\usepackage{balance}
\usepackage{listings}
\usepackage{xcolor}

% Configuración de colores para código
\definecolor{codegreen}{rgb}{0, 0.5, 0}
\definecolor{codegray}{rgb}{0.5, 0.5, 0.5}
\definecolor{codepurple}{rgb}{0.58, 0, 0.82}
\definecolor{backcolour}{rgb}{0.95, 0.95, 0.95}

% Configuración de listings para código C++
\lstset{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\small,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    language=C++
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PARCHE PARA ELIMINAR LA FECHA DEL DOCUMENTO
\usepackage{etoolbox}
\makeatletter
\patchcmd{\frontmatter@RRAP@format}{(}{}{}{}
\patchcmd{\frontmatter@RRAP@format}{)}{}{}{}
\makeatother	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{datetime}
\newdateformat{specialdate}{\twodigit{\THEDAY}-\twodigit{\THEMONTH}-\THEYEAR}
\date{\specialdate\today}

\renewcommand\spanishtablename{Tabla}
\renewcommand\spanishfigurename{Figura}

% --- DATOS DE LA PORTADA
\title{Sistema Decodificador de Protocolo Industrial (PRT-7)}
\author{
    \textbf{Alumno:} \\
    Junior Arturo Vazquez Leonel \\[1cm] % <-- TU NOMBRE AQUÍ
    \textbf{Asignatura:} \\
    Estructura de Datos \\[1cm]
    \textbf{Doctor:} \\
    SAID POLANCO MARTAGÓN % <-- LÍNEA EN BLANCO ELIMINADA
}
\date{6 de noviembre del 2025}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions
\newcommand{\breite}{1.0}
\newcommand{\RelacionFiguradoscolumnas}{0.9}
\newcommand{\RelacionFiguradoscolumnasPuntoCinco}{0.45}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% --- 1. PORTADA ---
\makeatletter % Permite el uso de comandos internos con @
\begin{titlepage}
    \centering
    \includegraphics[width=0.4\textwidth]{logo_upv.png}\\[1cm] % Reemplaza 'logo_upv.png' con el logo de tu universidad
    \Huge
    \textbf{Universidad Politécnica de Victoria}\\[2cm]
    
    \Large
    \textbf{Ingeniería en Tecnologías de la Información e Innovación Digital}\\[2cm]
    
    \rule{\linewidth}{0.5mm} \\[0.4cm]
    { \LARGE \bfseries \@title} % --- CORREGIDO ---
    \rule{\linewidth}{0.5mm} \\[1.5cm]
    
    \Large
    \@author % --- CORREGIDO ---
    
    \vfill
    \Large
    \@date % --- CORREGIDO ---
\end{titlepage}
\makeatother % Desactiva el permiso para comandos con @

\section{Introducción}
En el ámbito de la Industria 4.0 y el Internet de las Cosas (IoT), la transmisión de datos entre sensores y estaciones centrales es fundamental. A menudo, estos datos se envían en formatos compactos o protocolos personalizados que requieren un procesamiento en el lado del receptor para ser interpretados.

El proyecto "Sistema Decodificador de Protocolo Industrial (PRT-7)" simula este escenario. Se utiliza un microcontrolador ESP32 como \textit{emisor}, que envía una secuencia de tramas de datos a través del puerto serial. Una aplicación C++ en el lado del \textit{receptor} (una PC) escucha este puerto, interpreta las tramas y reconstruye un mensaje oculto.

El protocolo PRT-7 diseñado para este proyecto consta de dos tipos de tramas:
\begin{itemize}
    \item \textbf{Trama de Carga (LOAD):} Formato \texttt{L,<caracter>}. Indica que un carácter debe ser decodificado y agregado al mensaje.
    \item \textbf{Trama de Mapeo (MAP):} Formato \texttt{M,<numero>}. Indica que el estado del decodificador (el rotor) debe cambiar, rotando su posición.
\end{itemize}

El objetivo principal de este trabajo es aplicar los conceptos teóricos de estructuras de datos, específicamente listas doblemente enlazadas y listas circulares, para resolver un problema práctico de decodificación de datos. Se utiliza polimorfismo para gestionar los diferentes tipos de tramas, demostrando un diseño de software orientado a objetos limpio y extensible.

\section{Manual Técnico}
Esta sección detalla la arquitectura del sistema, el diseño de las estructuras de datos y el flujo de procesamiento de la información.

\subsection{Diseño y Arquitectura}
El sistema se divide en dos componentes principales: el Emisor (ESP32) y el Receptor (PC).

\subsubsection{Emisor (ESP32)}
El programa \texttt{DecodificadorPRT7.ino} se carga en un ESP32. Su única función es simular un sensor que envía datos. Define un arreglo de tramas (ej: "L,E", "L,L", "M,2", etc.) y las envía una por una a través de \texttt{Serial.println()} con un retardo de 1 segundo entre cada una. Al finalizar la secuencia, envía un mensaje de reinicio y vuelve a empezar.

\subsubsection{Receptor (PC)}
Es la aplicación principal (\texttt{main.cpp}). Se conecta al puerto serial (ej: \texttt{/dev/ttyUSB0}) y entra en un bucle de lectura. Utiliza dos estructuras de datos clave para su funcionamiento: \texttt{RotorDeMapeo} y \texttt{ListaDeCarga}.

\subsubsection{Diseño de Clases (Polimorfismo)}
Para manejar las tramas \texttt{L} y \texttt{M} de manera elegante, se utiliza un diseño basado en polimorfismo:
\begin{itemize}
    \item \textbf{TramaBase:} Es una clase base abstracta que define la interfaz \texttt{virtual void procesar(...)}.
    \item \textbf{TramaLoad:} Hereda de \texttt{TramaBase}. Implementa \texttt{procesar()} para decodificar un carácter usando el rotor y agregarlo a la lista de carga.
    \item \textbf{TramaMap:} Hereda de \texttt{TramaBase}. Implementa \texttt{procesar()} para rotar la posición del rotor de mapeo.
\end{itemize}
En \texttt{main.cpp}, al recibir una línea, se crea un objeto del tipo correspondiente (\texttt{new TramaLoad(...)} o \texttt{new TramaMap(...)}) y se invoca su método \texttt{procesar()}, permitiendo que cada objeto maneje su propia lógica.

\subsection{Componentes (Estructuras de Datos)}
El núcleo del proyecto son dos listas enlazadas implementadas manualmente.

\subsubsection{RotorDeMapeo (Lista Circular Doblemente Enlazada)}
Esta estructura actúa como un disco de cifrado César dinámico.
\begin{itemize}
    \item \textbf{Estructura:} Implementada como una lista circular doblemente enlazada usando \texttt{NodoRotor}. Cada nodo almacena un \texttt{char} (de 'A' a 'Z' más un espacio).
    \item \textbf{Nodos:} \texttt{NodoRotor} contiene \texttt{char dato}, \texttt{NodoRotor* siguiente}, y \texttt{NodoRotor* previo}.
    \item \textbf{Estado:} Mantiene un puntero \texttt{cabeza} que indica la posición "cero" actual del rotor. Inicialmente, \texttt{cabeza} apunta a 'A'.
    \item \textbf{Operación (Cifrado):} El método \texttt{getMapeo(char in)} decodifica un carácter. Lo hace calculando el \textit{offset} del carácter de entrada respecto a 'A' (ej: 'C' tiene un offset de 2) y avanza ese mismo número de posiciones desde el nodo \texttt{cabeza} actual.
    \item \textbf{Operación (Rotación):} El método \texttt{rotar(int n)} simplemente mueve el puntero \texttt{cabeza} \texttt{n} posiciones hacia adelante (si \texttt{n} es positivo) o hacia atrás (si \texttt{n} es negativo) en la lista circular.
\end{itemize}

\subsubsection{ListaDeCarga (Lista Doblemente Enlazada)}
Esta estructura almacena el mensaje final decodificado.
\begin{itemize}
    \item \textbf{Estructura:} Implementada como una lista doblemente enlazada estándar, con punteros \texttt{cabeza} y \texttt{cola}.
    \item \textbf{Nodos:} \texttt{NodoCarga} almacena el carácter original (\texttt{datoCodificado}) y el carácter resultante de la decodificación (\texttt{datoDecodificado}).
    \item \textbf{Operación (Inserción):} El método \texttt{insertarAlFinal(char codif, char decodif)} crea un nuevo \texttt{NodoCarga} y lo añade al final de la lista, actualizando el puntero \texttt{cola}.
    \item \textbf{Operación (Impresión):} El método \texttt{imprimirMensaje()} recorre la lista desde \texttt{cabeza} hasta \texttt{cola} e imprime solo el \texttt{datoDecodificado} de cada nodo.
\end{itemize}

\subsection{Desarrollo y Flujo de Procesamiento}
El flujo de datos completo, desde la transmisión hasta la decodificación final, sigue estos pasos:

\textbf{1. Transmisión:} El ESP32 envía una trama, por ejemplo: \texttt{L,E}.

\textbf{2. Recepción:} \texttt{main.cpp} lee la línea \texttt{"L,E"} del puerto serial.

\textbf{3. Parseo:} La función \texttt{procesarLinea} identifica el tipo 'L' y el dato 'E'.

\textbf{4. Creación Polimórfica:} Se instancia un objeto \texttt{TramaLoad}:\\
\texttt{TramaBase* trama = new TramaLoad('E');}

\textbf{5. Procesamiento (Caso TramaLoad):} Se invoca \texttt{trama->procesar(carga, rotor);}.
\begin{enumerate}
    \item \texttt{TramaLoad::procesar} llama a \texttt{rotor->getMapeo('E')}.
    \item \texttt{RotorDeMapeo::getMapeo('E')} calcula el offset de 'E' (4) y busca el nodo 4 posiciones después de la \texttt{cabeza} actual. Si la \texttt{cabeza} apunta a 'A', el resultado es 'E'.
    \item \texttt{TramaLoad::procesar} llama a \texttt{carga->insertarAlFinal('E', 'E')}.
    \item \texttt{ListaDeCarga::insertarAlFinal} crea un \texttt{NodoCarga} y lo añade al final de la lista de carga.
\end{enumerate}

\textbf{6. Transmisión (Trama de Mapeo):} El ESP32 envía la trama \texttt{M,2}.

\textbf{7. Procesamiento (Caso TramaMap):}
\begin{enumerate}
    \item Se crea \texttt{TramaBase* trama = new TramaMap(2);}.
    \item Se invoca \texttt{trama->procesar(carga, rotor);}.
    \item \texttt{TramaMap::procesar} llama a \texttt{rotor->rotar(2)}.
    \item \texttt{RotorDeMapeo::rotar(2)} mueve el puntero \texttt{cabeza} dos posiciones hacia adelante. La \texttt{cabeza} ahora apunta a 'C'. El mapeo ha cambiado: ahora 'A' se decodifica como 'C'.
\end{enumerate}

\textbf{8. Transmisión (Siguiente TramaLoad):} El ESP32 envía \texttt{L,A}.

\textbf{9. Procesamiento (Efecto del Mapeo):}
\begin{enumerate}
    \item Se crea \texttt{TramaBase* trama = new TramaLoad('A');}.
    \item \texttt{TramaLoad::procesar} llama a \texttt{rotor->getMapeo('A')}.
    \item \texttt{RotorDeMapeo::getMapeo('A')} calcula el offset de 'A' (0). Como la \texttt{cabeza} ahora apunta a 'C', el resultado de la decodificación es 'C'.
    \item \texttt{TramaLoad::procesar} llama a \texttt{carga->insertarAlFinal('A', 'C')}.
\end{enumerate}

\textbf{10. Resultado Final:} Este proceso se repite. Cuando la aplicación receptora detecta el mensaje "REINICIANDO SECUENCIA", llama a \texttt{carga->imprimirMensaje()}, que recorre la \texttt{ListaDeCarga} y muestra el mensaje oculto ensamblado.

\subsection{Implementación de Clases}
A continuación se presentan las cabeceras (.h) de las clases principales que definen la arquitectura del sistema.

\subsubsection{TramaBase}
\begin{lstlisting}[caption={TramaBase.h}, label={lst:tramabase}]
#ifndef TRAMABASE_H
#define TRAMABASE_H

// Forward declarations
class ListaDeCarga;
class RotorDeMapeo;

class TramaBase {
public:
    virtual ~TramaBase() {}
    virtual void procesar(ListaDeCarga* carga, RotorDeMapeo* rotor) = 0;
};

#endif // TRAMABASE_H
\end{lstlisting}
\textbf{Explicación:} Esta es la clase base abstracta. Define la interfaz común \texttt{procesar(...)} que todas las tramas (Load y Map) deben implementar. El uso de un destructor virtual \texttt{\~TramaBase()} es crucial para asegurar que se llame al destructor correcto (el de la clase derivada) cuando se elimina un objeto a través de un puntero a \texttt{TramaBase}, evitando fugas de memoria.

\subsubsection{RotorDeMapeo (Lista Circular)}
\begin{lstlisting}[caption={RotorDeMapeo.h}, label={lst:rotor_h}]
#ifndef ROTORDEMAPEO_H
#define ROTORDEMAPEO_H

struct NodoRotor {
    char dato;
    NodoRotor* siguiente;
    NodoRotor* previo;
    
    NodoRotor(char c) : dato(c), siguiente(nullptr), previo(nullptr) {}
};

class RotorDeMapeo {
private:
    NodoRotor* cabeza;
    int tamanio;
    
    NodoRotor* encontrarNodo(char c) const;
    int calcularDistancia(NodoRotor* desde, NodoRotor* hasta) const;
    
public:
    RotorDeMapeo();
    ~RotorDeMapeo();
    
    void rotar(int n);
    char getMapeo(char in) const;
    char getPosicionActual() const;
};

#endif // ROTORDEMAPEO_H
\end{lstlisting}
\textbf{Explicación:} Esta es la interfaz para la lista circular doblemente enlazada. Actúa como el disco de cifrado. Su constructor crea el alfabeto ('A'-'Z' y ' ') y su destructor libera la memoria. \texttt{rotar(n)} mueve el puntero \texttt{cabeza}, que es el que marca la referencia de cifrado. \texttt{getMapeo(char in)} calcula la decodificación.

\subsubsection{ListaDeCarga (Lista Doble)}
\begin{lstlisting}[caption={ListaDeCarga.h}, label={lst:lista_h}]
#ifndef LISTADECARGA_H
#define LISTADECARGA_H

struct NodoCarga {
    char datoCodificado;
    char datoDecodificado;
    NodoCarga* siguiente;
    NodoCarga* previo;
    
    NodoCarga(char codif, char decodif) : datoCodificado(codif), datoDecodificado(decodif), 
                                           siguiente(nullptr), previo(nullptr) {}
};

class ListaDeCarga {
private:
    NodoCarga* cabeza;
    NodoCarga* cola;
    int tamanio;
    
public:
    ListaDeCarga();
    ~ListaDeCarga();
    
    void insertarAlFinal(char codificado, char decodificado);
    void imprimirMensaje() const;
    void imprimirMensajeParcial() const;
    int obtenerTamanio() const;
    bool estaVacia() const;
};

#endif // LISTADECARGA_H
\end{lstlisting}
\textbf{Explicación:} Define la interfaz para una lista doblemente enlazada estándar que almacenará el mensaje. Mantiene punteros a \texttt{cabeza} y \texttt{cola} para inserciones eficientes al final. Define los métodos para \texttt{insertarAlFinal(...)} y para \texttt{imprimirMensaje()} y \texttt{imprimirMensajeParcial()}.

\subsubsection{TramaLoad}
\begin{lstlisting}[caption={TramaLoad.h}, label={lst:load_h}]
#ifndef TRAMALOAD_H
#define TRAMALOAD_H

#include "TramaBase.h"

class TramaLoad : public TramaBase {
private:
    char dato;
    
public:
    TramaLoad(char c);
    ~TramaLoad();
    
    void procesar(ListaDeCarga* carga, RotorDeMapeo* rotor) override;
};

#endif // TRAMALOAD_H
\end{lstlisting}
\textbf{Explicación:} Clase derivada que hereda de \texttt{TramaBase} y maneja las tramas "L". Almacena el carácter recibido (\texttt{dato}). Sobrescribe el método \texttt{procesar(...)} para implementar la lógica de decodificación (usando el Rotor) y almacenamiento (usando la ListaDeCarga).

\subsubsection{TramaMap}
\begin{lstlisting}[caption={TramaMap.h}, label={lst:map_h}]
#ifndef TRAMAMAP_H
#define TRAMAMAP_H

#include "TramaBase.h"

class TramaMap : public TramaBase {
private:
    int rotacion;
    
public:
    TramaMap(int n);
    ~TramaMap();
    
    void procesar(ListaDeCarga* carga, RotorDeMapeo* rotor) override;
};

#endif // TRAMAMAP_H
\end{lstlisting}
\textbf{Explicación:} Clase derivada que hereda de \texttt{TramaBase} y maneja las tramas "M". Almacena el valor de la rotación (\texttt{rotacion}). Sobrescribe el método \texttt{procesar(...)} para simplemente invocar a \texttt{rotor->rotar(rotacion)}, cambiando el estado del cifrado.

\section{Resultados}
La ejecución del sistema demuestra la correcta implementación de las estructuras de datos y el procesamiento polimórfico de las tramas. La aplicación receptora (\texttt{main.cpp}) se conecta exitosamente al ESP32 que actúa como emisor.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\columnwidth]{aplicacion.png}
	\caption{Ejecución del decodificador PRT-7 recibiendo la secuencia de tramas del ESP32. Se observa cómo las tramas 'L' (LOAD) añaden caracteres y las tramas 'M' (MAP) alteran el rotor, cambiando el mapeo (ej: 'A' se mapea a 'C') para formar el mensaje "HOLA WORLD".}
	\label{fig:aplicacion}
\end{figure}

Como se observa en la Figura \ref{fig:aplicacion}, el programa principal decodifica el mensaje "HOLA WORLD". Al detectar la señal de reinicio del ESP32 ("REINICIANDO SECUENCIA"), el sistema muestra el mensaje ensamblado por la \texttt{ListaDeCarga} y libera la memoria del \texttt{RotorDeMapeo} y la \texttt{ListaDeCarga}, preparándose para una nueva secuencia.

Para verificar la robustez del sistema, se cargó una secuencia de tramas diferente en el emisor (ESP32), como se muestra en la Figura \ref{fig:otros_datos}.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\columnwidth]{otros_datos.png}
	\caption{Ejecución del sistema con un conjunto de tramas alternativo. El sistema decodifica correctamente el mensaje ELIAS DE JESUS, demostrando que la lógica del rotor y la lista de carga funcionan independientemente del contenido transmitido.}
	\label{fig:otros_datos}
\end{figure}

El sistema fue capaz de decodificar el mensaje ELIAS DE JESUS sin necesidad de modificar el código del receptor, validando el diseño modular y la correcta gestión de estado del \texttt{RotorDeMapeo} y la \texttt{ListaDeCarga}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FIN DEL CONTENIDO DEL REPORTE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}